<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CAD-like Drawing Tool</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: #f5f5f5;
    }
    .toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      z-index: 10;
    }
    .toolbar label {
      display: block;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <label><input type="checkbox" id="snapToggle"> Snap</label>
    <label><input type="checkbox" id="orthoToggle"> Ortogonal</label>
  </div>
  <canvas id="c"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <script>
    const canvas = new fabric.Canvas('c', {
      backgroundColor: '#f5f5f5',
      selection: false,
      preserveObjectStacking: true
    });

    canvas.setWidth(window.innerWidth);
    canvas.setHeight(window.innerHeight);

    let isPanning = false;
    let lastPosX, lastPosY;
    let snapEnabled = false;
    let orthoEnabled = false;
    let drawing = false;
    let currentLine = null;
    let points = [];

    // Add event listeners for checkboxes
    document.getElementById('snapToggle').addEventListener('change', e => snapEnabled = e.target.checked);
    document.getElementById('orthoToggle').addEventListener('change', e => orthoEnabled = e.target.checked);

    // Pan and zoom
    canvas.on('mouse:down', function(opt) {
      const evt = opt.e;
      if (evt.button === 1) {
        isPanning = true;
        lastPosX = evt.clientX;
        lastPosY = evt.clientY;
      } else if (evt.button === 0) {
        const pointer = canvas.getPointer(evt);

        if (drawing && currentLine) {
          const p = adjustPoint(pointer);
          currentLine.set({ x2: p.x, y2: p.y });
          currentLine.setCoords();
          canvas.renderAll();
          currentLine = null;
          drawing = false;
        } else {
          const p = adjustPoint(pointer);
          const line = new fabric.Line([p.x, p.y, p.x, p.y], {
            stroke: 'black',
            strokeWidth: 2,
            fill: 'gray',
            selectable: true,
            hasBorders: false,
            hasControls: false,
            objectCaching: false
          });
          canvas.add(line);
          currentLine = line;
          drawing = true;
        }
      }
    });

    canvas.on('mouse:move', function(opt) {
      const evt = opt.e;
      if (isPanning) {
        const delta = new fabric.Point(evt.clientX - lastPosX, evt.clientY - lastPosY);
        canvas.relativePan(delta);
        lastPosX = evt.clientX;
        lastPosY = evt.clientY;
      } else if (drawing && currentLine) {
        const pointer = adjustPoint(canvas.getPointer(evt));
        currentLine.set({ x2: pointer.x, y2: pointer.y });
        currentLine.setCoords();
        canvas.renderAll();
      }
    });

    canvas.on('mouse:up', function(opt) {
      isPanning = false;
    });

    canvas.on('mouse:wheel', function(opt) {
      const delta = opt.e.deltaY;
      let zoom = canvas.getZoom();
      zoom *= 0.999 ** delta;
      if (zoom > 20) zoom = 20;
      if (zoom < 0.2) zoom = 0.2;
      canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
      opt.e.preventDefault();
      opt.e.stopPropagation();
    });

    function adjustPoint(p) {
      if (snapEnabled) {
        const snap = 10;
        p.x = Math.round(p.x / snap) * snap;
        p.y = Math.round(p.y / snap) * snap;
      }
      if (orthoEnabled && currentLine) {
        const dx = p.x - currentLine.x1;
        const dy = p.y - currentLine.y1;
        if (Math.abs(dx) > Math.abs(dy)) {
          p.y = currentLine.y1;
        } else {
          p.x = currentLine.x1;
        }
      }
      return p;
    }
  </script>
</body>
</html>
